import React, { createContext, useContext, useState, ReactNode, useEffect } from "react";
// Assuming 'api' is a pre-configured axios instance
import api from '../lib/api'; 
// Assuming useToast is a custom hook for showing notifications
import { useToast } from "@/hooks/use-toast";

// --- INTERFACES ---
// Represents a single question
export interface Pergunta {
  id: string;
  texto: string;
  tipo: 'nota' | 'texto' | 'multipla_escolha';
  opcoes?: string[];
  ativo?: boolean;
  dataCriacao?: string;
  dataAtualizacao?: string;
}

// Represents a form, which contains multiple questions
export interface Formulario {
  id: string;
  titulo: string;
  descricao: string;
  ativo: boolean;
  perguntas: Pergunta[]; // Note: This will now be consistent
}

// Type for creating a new question (ID is generated by backend)
export type NewQuestionData = Omit<Pergunta, 'id' | 'ativo' | 'dataCriacao' | 'dataAtualizacao'>;

// Type for the payload when creating or updating a form
export type FormPayload = {
  titulo: string;
  descricao: string;
  idsPerguntas: string[];
};

// --- CONTEXT TYPE ---
interface FormContextType {
  formularios: Formulario[];
  perguntas: Pergunta[];
  loading: boolean;
  getFormById: (formId: string) => Promise<Formulario | void>;
  addForm: (formData: FormPayload) => Promise<Formulario | void>;
  addQuestion: (questionData: NewQuestionData) => Promise<Pergunta | void>;
  deleteForm: (formId: string) => Promise<void>;
  updateForm: (formId: string, updatedData: Partial<FormPayload>) => Promise<Formulario | void>;
}

const FormContext = createContext<FormContextType | undefined>(undefined);

// --- HELPER FUNCTION FOR DATA MAPPING ---
// This function normalizes inconsistent API responses for forms.
// It can now handle properties with or without underscores (e.g., p.id or p._id).
const mapApiFormToFormulario = (apiForm: any): Formulario => {
    return {
        ...apiForm,
        perguntas: (apiForm.perguntas || []).map((p: any) => ({
            id: p.id || p._id,
            texto: p.texto || p._texto,
            tipo: p.tipo || p._tipo,
            opcoes: p.opcoes || p._opcoes,
            ativo: p.ativo ?? p._ativo, // Use nullish coalescing for boolean
            dataCriacao: p.dataCriacao || p._dataCriacao,
            dataAtualizacao: p.dataAtualizacao || p._dataAtualizacao,
        })),
    };
};


// --- PROVIDER COMPONENT ---
export const FormProvider = ({ children }: { children: ReactNode }) => {
  const [formularios, setFormularios] = useState<Formulario[]>([]);
  const [perguntas, setPerguntas] = useState<Pergunta[]>([]);
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const [formsRes, questionsRes] = await Promise.all([
          api.get('/formularios'),
          api.get('/perguntas')
        ]);

        // Map the incoming form data to be consistent
        const mappedForms = formsRes.data.map(mapApiFormToFormulario);
        setFormularios(mappedForms);
        
        // Questions data is assumed to be in the correct format
        setPerguntas(questionsRes.data);

      } catch (error) {
        console.error("Erro ao buscar dados:", error);
        toast({ title: "Erro de Rede", description: "Não foi possível carregar os dados.", variant: "destructive" });
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [toast]);

  const getFormById = async (formId: string): Promise<Formulario | void> => {
    try {
      const response = await api.get(`/formulario/${formId}`);
      // Map the single form data to be consistent
      return mapApiFormToFormulario(response.data);
    } catch (error) {
      console.error(`Erro ao buscar formulário ${formId}:`, error);
      toast({ title: "Erro", description: "Não foi possível carregar os detalhes do formulário.", variant: "destructive" });
    }
  };

  const addForm = async (formData: FormPayload) => {
    try {
      const response = await api.post('/formulario', formData);
      const newForm = mapApiFormToFormulario(response.data); // Map the response
      setFormularios(current => [...current, newForm]);
      toast({ title: "Sucesso", description: "Formulário criado com sucesso!" });
      return newForm;
    } catch (error) {
      console.error("Erro ao criar formulário:", error);
      toast({ title: "Erro", description: "Não foi possível criar o formulário.", variant: "destructive" });
    }
  };

  const deleteForm = async (formId: string) => {
    try {
      await api.delete(`/delete-formulario/${formId}`);
      setFormularios(current => current.filter(form => form.id !== formId));
      toast({ title: "Sucesso", description: "Formulário excluído com sucesso!" });
    }
    catch (error) {
      console.error("Erro ao excluir formulário:", error);
      toast({ title: "Erro", description: "Não foi possível excluir o formulário.", variant: "destructive" });
    }
  };

  const updateForm = async (formId: string, updatedData: Partial<FormPayload>) => {
    try {
      const response = await api.put(`/update-formulario/${formId}`, updatedData);
      const updatedForm = mapApiFormToFormulario(response.data); // Map the response
      setFormularios(current => current.map(form => (form.id === formId ? updatedForm : form)));
      toast({ title: "Sucesso", description: "Formulário atualizado com sucesso!" });
      return updatedForm;
    } catch (error) {
      console.error("Erro ao atualizar formulário:", error);
      toast({ title: "Erro", description: "Não foi possível atualizar o formulário.", variant: "destructive" });
    }
  };

  const addQuestion = async (questionData: NewQuestionData) => {
    try {
      const response = await api.post('/pergunta', questionData);
      const newQuestion = response.data;
      setPerguntas(current => [...current, newQuestion]);
      toast({ title: "Sucesso", description: "Nova pergunta adicionada!" });
      return newQuestion;
    } catch (error) {
      console.error("Erro ao criar pergunta:", error);
      toast({ title: "Erro", description: "Não foi possível criar a pergunta.", variant: "destructive" });
    }
  };

  return (
    <FormContext.Provider value={{ formularios, perguntas, loading, getFormById, addForm, addQuestion, deleteForm, updateForm }}>
      {children}
    </FormContext.Provider>
  );
};

// --- CUSTOM HOOK ---
export const useForm = (): FormContextType => {
  const context = useContext(FormContext);
  if (!context) throw new Error("useForm must be used within a FormProvider");
  return context;
};
